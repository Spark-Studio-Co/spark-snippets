{
  "Spark React Input": {
    "prefix": "rinput",
    "body": [
      "import React from 'react';",
      "import styles from './styles.module.scss';",
      "",
      "interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {",
      "  margin?: string;",
      "  placeholder: string;",
      "  type: string;",
      "  textAlign?: 'left' | 'center' | 'right';",
      "}",
      "",
      "const Input: React.FC<InputProps> = ({",
      "  margin,",
      "  placeholder,",
      "  type,",
      "  textAlign = 'left',",
      "  ...rest",
      "}) => {",
      "  const inputClass = `${styles.input} ${margin ? styles[margin] : ''}`;",
      "  const inputStyle = { textAlign };",
      "",
      "  return (",
      "    <input",
      "      className={inputClass}",
      "      style={inputStyle}",
      "      type={type}",
      "      placeholder={placeholder}",
      "      {...rest}",
      "    />",
      "  );",
      "};",
      "",
      "export default Input;",
      ""
    ],
    "description": "Creates a styled input component with optional text alignment and margin styles."
  },

  "Spark React Button": {
    "prefix": "rbtn",
    "body": [
      "import React from 'react';",
      "import styles from './styles.module.scss';",
      "",
      "interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {",
      "  margin?: string;",
      "  text: string;",
      "  buttonType: 'filled' | 'outline';",
      "}",
      "",
      "const Button: React.FC<ButtonProps> = ({",
      "  margin,",
      "  text,",
      "  buttonType,",
      "  ...rest",
      "}) => {",
      "  const buttonClass = `${styles.button} ${styles['button--' + buttonType]} ${margin || ''}`;",
      "",
      "  return (",
      "    <button",
      "      className={buttonClass}",
      "      {...rest}",
      "    >",
      "      {text}",
      "    </button>",
      "  );",
      "};",
      "",
      "export default Button;",
      "",
      "// Usage Example:",
      "// <Button",
      "//   margin='mt-4'",
      "//   text='Submit'",
      "//   buttonType='filled'",
      "//   onClick={() => console.log('Button clicked')}",
      "// />"
    ],
    "description": "Creates a styled button component using SCSS modules, supporting 'filled' or 'outline' styles."
  },

  "Spark Horizontal Rule": {
    "prefix": "rhr",
    "body": [
      "import React from 'react';",
      "import styles from './styles.module.scss';",
      "",
      "interface HRProps {",
      "  className?: string;",
      "}",
      "",
      "export const HorizontalRule: React.FC<HRProps> = ({ className }) => {",
      "  return <hr className={`${styles.hr} ${className}`} />;",
      "};"
    ],
    "description": "React component for a styled <hr> element using SCSS"
  },

  "Spark React Link Button": {
    "prefix": "rlbtn",
    "body": [
      "import React from 'react';",
      "import { Link } from 'react-scroll';",
      "import styles from './styles.module.scss';",
      "",
      "interface ButtonLinkProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {",
      "  margin?: string;",
      "  text: string;",
      "  to: string;",
      "  buttonType: 'filled' | 'outline';",
      "}",
      "",
      "const LinkButton: React.FC<ButtonLinkProps> = ({",
      "  margin,",
      "  text,",
      "  to,",
      "  buttonType,",
      "  ...rest",
      "}) => {",
      "  const buttonClass = `${styles.button} ${styles['button--' + buttonType]} ${margin || ''}`;",
      "",
      "  return (",
      "    <Link",
      "      className={buttonClass}",
      "      to={to}",
      "      {...rest}",
      ">",
      "      {text}",
      "    </Link>",
      "  );",
      "};",
      "",
      "export default LinkButton;",
      "",
      "// Usage Example:",
      "// <LinkButton",
      "//   margin='mb-4'",
      "//   text='Click Me'",
      "//   to='targetSection'",
      "//   buttonType='filled'",
      "//   onClick={() => console.log('Navigating to section')}",
      "// />"
    ],
    "description": "Creates a styled Link button using react-scroll, supports both filled and outline styles"
  },

  "Spark React Selector": {
    "prefix": "rselector",
    "body": [
      "import React, { useState } from 'react';",
      "import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';",
      "import { faChevronDown, faChevronUp } from '@fortawesome/free-solid-svg-icons';",
      "import styles from './styles.module.scss';",
      "",
      "interface SelectorProps {",
      "  placeholder: string;",
      "  value: string;",
      "  margin: string;",
      "  onChange: (value: string) => void;",
      "  options: { label: string; value: string }[];",
      "}",
      "",
      "const Selector: React.FC<SelectorProps> = ({",
      "  placeholder,",
      "  value,",
      "  margin,",
      "  onChange,",
      "  options",
      "}) => {",
      "  const [isOpen, setIsOpen] = useState(false);",
      "",
      "  const toggleDropdown = () => setIsOpen(!isOpen);",
      "  const handleOptionClick = (selectedValue: string) => {",
      "    onChange(selectedValue);",
      "    setIsOpen(false);",
      "  };",
      "",
      "  return (",
      "    <div className={`w-full flex flex-col items-center ${margin}`}>",
      "      <div",
      "        className={styles.selector}",
      "        onClick={toggleDropdown}",
      "      >",
      "        <span className={styles.selectorPlaceholder}>{value || placeholder}</span>",
      "        <FontAwesomeIcon",
      "          className={styles.selectorChevron}",
      "          icon={isOpen ? faChevronUp : faChevronDown}",
      "        />",
      "      </div>",
      "      {isOpen && (",
      "        <ul className={styles.list}>",
      "          {options.map((option) => (",
      "            <li",
      "              key={option.value}",
      "              onClick={() => handleOptionClick(option.value)}",
      "              className={styles.listItem}",
      "            >",
      "              {option.label}",
      "            </li>",
      "          ))}",
      "        </ul>",
      "      )}",
      "    </div>",
      "  );",
      "};",
      "",
      "export default Selector;"
    ],
    "description": "Custom dropdown selector component using React and FontAwesome"
  },

  "Spark Post Request": {
    "prefix": "rapost",
    "body": [
      "import axios from 'axios';",
      "",
      "interface IData {",
      "    data1: string;",
      "    data2: string;",
      "    data3: string;",
      "    data4: string;",
      "}",
      "",
      "export async function createPOst(data: IData): Promise<void> {",
      "    try {",
      "        const response = await axios.post('YOUR_URL_HERE', data);",
      "        console.log('Data created:', response.data);",
      "        window.location.href = '/YOUR_SUCCESS_ROUTE';",
      "    } catch (error: unknown | any) {",
      "        console.error('Failed to create data:', error);",
      "        if (error.response) {",
      "            return error.response.data.message;",
      "        } else {",
      "            return 'An unexpected error occurred';",
      "        }",
      "    }",
      "}",
      ""
    ],
    "description": "Spark Post Request With Axios"
  },

  "Spark Post Request with Bearer Token": {
    "prefix": "rabpost",
    "body": [
      "import axios from 'axios';",
      "",
      "interface IData {",
      "    data1: string;",
      "    data2: string;",
      "    data3: string;",
      "    data4: string;",
      "}",
      "",
      "export async function createData(data: IData, token: string): Promise<void> {",
      "    const config = {",
      "        headers: { 'Authorization': `Bearer ${token}` }",
      "    };",
      "",
      "    try {",
      "        const response = await axios.post('YOUR_URL_HERE', data, config);",
      "        console.log('Data created:', response.data);",
      "        window.location.href = '/YOUR_SUCCESS_ROUTE';",
      "    } catch (error: unknown | any) {",
      "        console.error('Failed to create data:', error);",
      "        return error.response ? error.response.data.message : 'An unexpected error occurred';",
      "    }",
      "}",
      ""
    ],
    "description": "Spark Post Request With Axios including Bearer Token Authentication"
  },

  "Spark Get Request": {
    "prefix": "raget",
    "body": [
      "import axios from 'axios';",
      "import { useState, useEffect } from 'react';",
      "",
      "interface IResponseData {",
      "    dataField1: string;",
      "    dataField2: string;",
      "    dataField3: string;",
      "}",
      "",
      "export function useFetchData(url: string) {",
      "    const [data, setData] = useState<IResponseData | null>(null);",
      "    const [isLoading, setIsLoading] = useState<boolean>(true);",
      "    const [error, setError] = useState<string | null>(null);",
      "",
      "    useEffect(() => {",
      "        const fetchData = async () => {",
      "            try {",
      "                const response = await axios.get<IResponseData>(url);",
      "                setData(response.data);",
      "                setIsLoading(false);",
      "            } catch (error: unknown | any) {",
      "                setError('Failed to fetch data: ' + (error.response?.data.message || error.message));",
      "                setIsLoading(false);",
      "            }",
      "        };",
      "",
      "        fetchData();",
      "    }, [url]);",
      "",
      "    return { data, isLoading, error };",
      "}",
      ""
    ],
    "description": "Spark Get Request using useState and axios for fetching data"
  },

  "Spark Get Request with Bearer Token": {
    "prefix": "rabget",
    "body": [
      "import axios from 'axios';",
      "import { useState, useEffect } from 'react';",
      "",
      "interface IResponseData {",
      "    dataField1: string;",
      "    dataField2: string;",
      "    dataField3: string;",
      "}",
      "",
      "export function useFetchData(url: string, token: string) {",
      "    const [data, setData] = useState<IResponseData | null>(null);",
      "    const [isLoading, setIsLoading] = useState<boolean>(true);",
      "    const [error, setError] = useState<string | null>(null);",
      "",
      "    useEffect(() => {",
      "        const fetchData = async () => {",
      "            const config = {",
      "                headers: { 'Authorization': `Bearer ${token}` }",
      "            };",
      "            try {",
      "                const response = await axios.get<IResponseData>(url, config);",
      "                setData(response.data);",
      "                setIsLoading(false);",
      "            } catch (error: unknown | any) {",
      "                setError('Failed to fetch data: ' + (error.response?.data.message || error.message));",
      "                setIsLoading(false);",
      "            }",
      "        };",
      "        fetchData();",
      "    }, [url, token]);",
      "",
      "    return { data, isLoading, error };",
      "}",
      ""
    ],
    "description": "Spark Get Request with useState, axios, and Bearer token authentication for fetching data"
  },

  "Spark Delete Request": {
    "prefix": "radelete",
    "body": [
      "import axios from 'axios';",
      "",
      "export async function deleteResource(url: string): Promise<void> {",
      "    try {",
      "        const response = await axios.delete(url);",
      "        console.log('Resource deleted successfully:', response.data);",
      "    } catch (error: unknown | any) {",
      "        console.error('Failed to delete resource:', error);",
      "        return error.response ? error.response.data.message : 'An unexpected error occurred';",
      "    }",
      "}",
      ""
    ],
    "description": "Spark Delete Request without Bearer Token using Axios"
  },

  "Spark Delete Request with Bearer Token": {
    "prefix": "rabdelete",
    "body": [
      "import axios from 'axios';",
      "",
      "export async function deleteResourceWithToken(url: string, token: string): Promise<void> {",
      "    const config = {",
      "        headers: { 'Authorization': `Bearer ${token}` }",
      "    };",
      "    try {",
      "        const response = await axios.delete(url, config);",
      "        console.log('Resource deleted successfully:', response.data);",
      "    } catch (error: unknown | any) {",
      "        console.error('Failed to delete resource:', error);",
      "        return error.response ? error.response.data.message : 'An unexpected error occurred';",
      "    }",
      "}",
      ""
    ],
    "description": "Spark Delete Request with Bearer Token using Axios"
  },

  "Spark Patch Request": {
    "prefix": "rapatch",
    "body": [
      "import axios from 'axios';",
      "",
      "export async function patchResource(url: string, updateData: object): Promise<void> {",
      "    try {",
      "        const response = await axios.patch(url, updateData);",
      "        console.log('Resource updated successfully:', response.data);",
      "    } catch (error: unknown | any) {",
      "        console.error('Failed to update resource:', error);",
      "        return error.response ? error.response.data.message : 'An unexpected error occurred';",
      "    }",
      "}",
      ""
    ],
    "description": "Spark Patch Request without Bearer Token using Axios"
  },

  "Spark Patch Request with Bearer Token": {
    "prefix": "rabpatch",
    "body": [
      "import axios from 'axios';",
      "",
      "export async function patchResourceWithToken(url: string, updateData: object, token: string): Promise<void> {",
      "    const config = {",
      "        headers: { 'Authorization': `Bearer ${token}` }",
      "    };",
      "    try {",
      "        const response = await axios.patch(url, updateData, config);",
      "        console.log('Resource updated successfully:', response.data);",
      "    } catch (error: unknown | any) {",
      "        console.error('Failed to update resource:', error);",
      "        return error.response ? error.response.data.message : 'An unexpected error occurred';",
      "    }",
      "}",
      ""
    ]
  },

  "Spark Links Interface and Array": {
    "prefix": "navlinksetup",
    "body": [
      "export interface NavLink {",
      "  label: string;",
      "  href: string;",
      "}",
      "",
      "export const navLinks: NavLink[] = [",
      "  { label: \"${1:Home}\", href: \"${2:/}\" },",
      "  { label: \"${3:Services}\", href: \"${4:/services}\" },",
      "  { label: \"${5:About}\", href: \"${6:/about}\" },",
      "  { label: \"${7:FAQ}\", href: \"${8:/faq}\" },",
      "  { label: \"${9:Blog}\", href: \"${10:/blog}\" },",
      "  { label: \"${11:Contact}\", href: \"${12:/contact}\" },",
      "];"
    ],
    "description": "Creates a NavLink interface and an array of nav links"
  },

  "Spark Create Error Handler": {
    "prefix": "createHandler",
    "body": [
      "// createErrorHandler.ts",
      "export type ErrorCodes = 'AMOUNT_OF_SYMBOLS' | 'CAPITAL_LETTER' | 'SMALL_LETTER' | 'ONE_NUMBER' | 'ONE_SPECIAL_SYMBOL' | 'PASSWORDS_NOT_MATCH' | 'EMAIL_FORMAT';",
      "",
      "export type SetErrorFunction = (field: string, message: string) => void;",
      "",
      "export const createErrorHandler = (setError: SetErrorFunction) => {",
      "    const errorMessages: Record<ErrorCodes, string> = {",
      "        AMOUNT_OF_SYMBOLS: 'Пароль должен содержать от 8 до 16 символов',",
      "        CAPITAL_LETTER: 'Пароль должен содержать хотя бы одну заглавную букву',",
      "        SMALL_LETTER: 'Пароль должен содержать хотя бы одну маленькую букву',",
      "        ONE_NUMBER: 'Пароль должен содержать хотя бы одну цифру',",
      "        ONE_SPECIAL_SYMBOL: 'Пароль должен содержать хотя бы один специальный символ',",
      "        PASSWORDS_NOT_MATCH: 'Пароли не совпадают',",
      "        EMAIL_FORMAT: 'Неверный формат email',",
      "    };",
      "",
      "    return (field: string, errorCode: ErrorCodes) => {",
      "        const message = errorMessages[errorCode] || 'An unexpected error occurred. Please try again.';",
      "        setError(field, message);",
      "    };",
      "};"
    ],
    "description": "Creates an error handler for form validation with predefined error codes and messages."
  },

  "Spark Validation Hook": {
    "prefix": "useFieldValidator",
    "body": [
      "import { useState } from 'react';",
      "import { createErrorHandler, ErrorCodes } from './useErrorHandler';",
      "",
      "export const useFieldValidator = () => {",
      "  const [errors, setErrors] = useState<Record<string, string>>({});",
      "",
      "  const errorHandler = createErrorHandler((field, message) => {",
      "    setErrors((prev) => ({ ...prev, [field]: message }));",
      "  });",
      "",
      "  const validateField = (",
      "    field: string,",
      "    value: string,",
      "    regex: RegExp,",
      "    errorCode: ErrorCodes",
      "  ) => {",
      "    if (!regex.test(value)) {",
      "      errorHandler(field, errorCode);",
      "      return false;",
      "    }",
      "    setErrors((prev) => ({ ...prev, [field]: '' }));",
      "    return true;",
      "  };",
      "",
      "  return { errors, validateField };",
      "};"
    ],
    "description": "React custom hook for validating form fields with error handling."
  },

  "Use Menu Animation Hook": {
    "prefix": "useMenuAnimation",
    "body": [
      "import { useRef, useEffect } from \"react\";",
      "import gsap from \"gsap\";",
      "",
      "export const useMenuAnimation = (",
      "  isOpen: boolean",
      "): {",
      "  menuRef: React.RefObject<HTMLDivElement>;",
      "} => {",
      "  const menuRef = useRef<HTMLDivElement>(null);",
      "",
      "  useEffect(() => {",
      "    try {",
      "      if (menuRef.current) {",
      "        const tl = gsap.timeline();",
      "",
      "        if (isOpen) {",
      "          tl.to(menuRef.current, {",
      "            y: \"2000%\",",
      "            autoAlpha: 1,",
      "            scale: 1,",
      "            duration: 1,",
      "            ease: \"power3.out\",",
      "          });",
      "        } else {",
      "          tl.to(menuRef.current, {",
      "            y: \"-2000%\",",
      "            autoAlpha: 0,",
      "            scale: 0.95,",
      "            duration: 0.3,",
      "            ease: \"power3.in\",",
      "            clearProps: \"all\",",
      "          });",
      "        }",
      "      }",
      "    } catch (error: any | unknown) {",
      "      console.log(\"There was an error with animation:\", error);",
      "    }",
      "  }, [isOpen]);",
      "",
      "  return { menuRef };",
      "};"
    ],
    "description": "Custom React hook for animating a menu using GSAP based on an open/close state."
  },

  "Use Burger Button Animation Hook": {
    "prefix": "useBurgerButtonAnimation",
    "body": [
      "import { useRef, useEffect } from \"react\";",
      "import gsap from \"gsap\";",
      "",
      "export const useBurgerButtonAnimation = (",
      "  isOpen: boolean",
      "): {",
      "  firstLine: React.RefObject<HTMLSpanElement>;",
      "  secondLine: React.RefObject<HTMLSpanElement>;",
      "  thirdLine: React.RefObject<HTMLSpanElement>;",
      "} => {",
      "  const firstLine = useRef<HTMLSpanElement>(null);",
      "  const secondLine = useRef<HTMLSpanElement>(null);",
      "  const thirdLine = useRef<HTMLSpanElement>(null);",
      "",
      "  useEffect(() => {",
      "    if (firstLine.current && secondLine.current && thirdLine.current) {",
      "      gsap.set([firstLine.current, thirdLine.current], {",
      "        transformOrigin: \"50% 50%\",",
      "      });",
      "",
      "      const openTl = gsap",
      "        .timeline({ paused: true })",
      "        .to(firstLine.current, { y: 0, rotation: 45, duration: 0.3 })",
      "        .to(thirdLine.current, { y: -16, rotation: -45, duration: 0.3 }, \"<\")",
      "        .to(secondLine.current, { scaleX: 0, duration: 0.2 }, \"<0.1\");",
      "",
      "      const closeTl = gsap",
      "        .timeline({ paused: true })",
      "        .to(firstLine.current, { y: 0, rotation: 0, duration: 0.3 })",
      "        .to(thirdLine.current, { y: 0, rotation: 0, duration: 0.3 }, \"<\")",
      "        .to(secondLine.current, { scaleX: 1, duration: 0.2 }, \"<0.1\");",
      "",
      "      if (isOpen) {",
      "        openTl.play();",
      "      } else {",
      "        closeTl.play();",
      "      }",
      "",
      "      return () => {",
      "        openTl.kill();",
      "        closeTl.kill();",
      "      };",
      "    }",
      "  }, [isOpen]);",
      "",
      "  return { firstLine, secondLine, thirdLine };",
      "};"
    ],
    "description": "Custom React hook for animating a burger button using GSAP based on an open/close state."
  }
}
